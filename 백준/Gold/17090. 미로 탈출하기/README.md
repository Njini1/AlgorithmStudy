# [Gold III] 미로 탈출하기 - 17090 

[문제 링크](https://www.acmicpc.net/problem/17090) 

### 성능 요약

메모리: 43860 KB, 시간: 204 ms

### 걸린 시간 및 난이도

- 1시간
- 하

### 풀이 리뷰

- 문제 보자마자 DFS이 생각남. DFS로 미로를 탐색하면서 결과를 return 하면서 방문 처리를 함.

### 풀이 키워드

- DFS
- DFS이기 때문에 방문한 지점은 이미 탐색이 종료되어 탈출 여부에 대한 결과값을 가지게 됨. → 그러므로 더 이상 그 지점은 탐색할 필요가 없음.

### 풀이 방법

- 탐색하면서 탈출 여부를 담은 2차원 배열을 만듦(result).
    - -1: 탈출 실패, 0: 탐색 x, 1: 탈출 성공
1. 처음 for문으로 탐색하지 않은 미로만 dfs로 탐색 → result 값이 0일 경우만 탐색
2. dfs로 탐색하면서 처음 값은 -1 로 저장. 범위를 벗어난 경우 즉, 탈출에 성공한 경우는 1을 반환.
3. 해당 미로의 값 상하좌우에 맞춰서 다음 dfs를 호출. 다음 dfs의 값을 해당 미로의 result에 저장.
→ 이 result의 값을 반환. 

⇒ 결국 계속 미로를 탐색하면서 탈출했다면 1을 반환하기 때문에 해당 이동 경로는 모두 1의 값을 가짐. 하지만 결과값을 저장한 지점을 만나고 그 값이 -1이라면 해당 지점에서는 더 이상 탈출할 수 없다는 뜻이기 때문에 -1 을 반환.

### 분류

깊이 우선 탐색, 다이나믹 프로그래밍, 그래프 이론, 그래프 탐색

### 제출 일자

2025년 2월 24일 17:51:26

### 문제 설명

<p>크기가 N×M인 미로가 있고, 미로는 크기가 1×1인 칸으로 나누어져 있다. 미로의 각 칸에는 문자가 하나 적혀있는데, 적혀있는 문자에 따라서 다른 칸으로 이동할 수 있다.</p>

<p>어떤 칸(r, c)에 적힌 문자가</p>

<ul>
	<li>U인 경우에는 (r-1, c)로 이동해야 한다.</li>
	<li>R인 경우에는 (r, c+1)로 이동해야 한다.</li>
	<li>D인 경우에는 (r+1, c)로 이동해야 한다.</li>
	<li>L인 경우에는 (r, c-1)로 이동해야 한다.</li>
</ul>

<p>미로에서 탈출 가능한 칸의 수를 계산해보자. 탈출 가능한 칸이란, 그 칸에서 이동을 시작해서 칸에 적힌대로 이동했을 때, 미로의 경계 밖으로 이동하게 되는 칸을 의미한다.</p>

### 입력 

 <p>첫째 줄에 미로의 크기 N, M(3 ≤ N, M ≤ 500)이 주어진다. 둘째 줄부터 N개의 줄에는 미로의 각 칸에 적힌 문자가 주어진다.</p>

### 출력 

 <p>첫째 줄에 탈출 가능한 칸의 수를 출력한다.</p>

